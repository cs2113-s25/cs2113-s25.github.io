<!DOCTYPE html>
<html lang="en">

  <a name="top"></a><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>C Memory Model | CS 2113 Software Engineering - Fall 2022</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="C Memory Model" />
<meta name="author" content="Kinga Dobolyi" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="CS 2113 Software Engineering." />
<meta property="og:description" content="CS 2113 Software Engineering." />
<link rel="canonical" href="http://localhost:4000/c/3" />
<meta property="og:url" content="http://localhost:4000/c/3" />
<meta property="og:site_name" content="CS 2113 Software Engineering - Fall 2022" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="C Memory Model" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Kinga Dobolyi"},"description":"CS 2113 Software Engineering.","headline":"C Memory Model","url":"http://localhost:4000/c/3"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="CS 2113 Software Engineering - Fall 2022" /><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
<link rel="manifest" href="/favicon/site.webmanifest">
<link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/favicon/browserconfig.xml">
<meta name="theme-color" content="#333333">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>   
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">CS 2113 Software Engineering - Fall 2022 </a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/guides">Guides</a><a class="page-link" href="/videos">Videos</a><a class="page-link" href="/schedule.html">Schedule</a><a class="page-link" href="/syllabus.html">Syllabus</a></div>
      </nav></div>


</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="table-of-contents">
      <h2>
        
        
           Table of Contents 
        
        
      </h2>
    
  <div class="text-table-of-contents">
    <ul><li><a href="#memory-model">Memory Model</a></li><li><a href="#local-memory-allocation-on-the-stack">Local Memory Allocation on the Stack</a><ul><li><a href="#the-stack">The Stack</a></li></ul></li><li><a href="#global-memory-allocation-on-the-heap">Global Memory Allocation on the Heap</a><ul><li><a href="#the-heap-malloc-and-free">The heap, <code class="language-plaintext highlighter-rouge">malloc()</code> and <code class="language-plaintext highlighter-rouge">free()</code></a></li><li><a href="#program-layout-stack-vs-heap">Program Layout: Stack vs. Heap</a></li></ul></li><li><a href="#memory-leaks-and-memory-violations">Memory Leaks and Memory Violations</a><ul><li><a href="#using-valgrind-to-detect-memory-leaks-and-violations">Using Valgrind to Detect Memory Leaks and Violations</a><ul><li><a href="#debugging-a-memleak-with-valgrind">Debugging a memleak with valgrind</a></li><li><a href="#understanding-a-memory-violation-using-valgrind">Understanding a memory violation using valgrind</a></li></ul></li></ul></li><li><a href="#dynamic-array-allocation">Dynamic Array Allocation</a><ul><li><a href="#array-allocation-with-calloc">Array allocation with <code class="language-plaintext highlighter-rouge">calloc()</code></a></li><li><a href="#double-pointer-arrays-for-advanced-data-types">Double Pointer Arrays for Advanced Data Types</a></li><li><a href="#deallocating-double-pointers">Deallocating Double Pointers</a></li></ul></li><li><a href="#programming-a-dynamic-data-structure-in-c">Programming a Dynamic Data Structure in C</a><ul><li><a href="#header-file">Header File</a><ul><li><a href="#structures-of-a-sstack">Structures of a <code class="language-plaintext highlighter-rouge">sstack</code></a></li><li><a href="#functions-over-the-sstack">Functions over the <code class="language-plaintext highlighter-rouge">sstack</code></a></li></ul></li><li><a href="#source-file">Source File</a><ul><li><a href="#allocating">Allocating</a></li><li><a href="#push">Push</a></li><li><a href="#pop">Pop</a></li><li><a href="#is-empty-and-size">Is Empty and Size</a></li><li><a href="#deallocating">Deallocating</a></li></ul></li><li><a href="#using-the-sstack">Using the <code class="language-plaintext highlighter-rouge">sstack</code></a></li></ul></li></ul></li></ul>

  </div>
</div>

<div class="goto-top">
  <a href="#top"> ^ Top of page</a>
</div>

<p><em>View all the videos from this unit a <a href="https://youtube.com/playlist?list=PLnVRBITSZMSPIx22PQz_rBfbKMjK4ApuX">single playlist on youtube</a></em></p>
      <h1 id="memory-model">
        
        
          Memory Model <a href="#memory-model">#</a>
        
        
      </h1>
    

<p>So far in programming C, we haven’t given a lot of thought to the variables we declare and what it actually means to declare a variable of a given type. Recall that in C the notion of a type and the amount of memory to store that type are strongly linked. For the basic types we’ve looked at so far, here are their memory requirements:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">int</code> : integer number : 4-bytes</li>
  <li><code class="language-plaintext highlighter-rouge">short</code> : integer number : 2-bytes</li>
  <li><code class="language-plaintext highlighter-rouge">long</code> : integer number : 8-bytes</li>
  <li><code class="language-plaintext highlighter-rouge">char</code> : character : 1-byte</li>
  <li><code class="language-plaintext highlighter-rouge">float</code> : floating point number : 4-bytes</li>
  <li><code class="language-plaintext highlighter-rouge">double</code> : floating point number : 8-bytes</li>
  <li><code class="language-plaintext highlighter-rouge">void *</code> : pointers : 8-bytes on (64 bit machines)</li>
</ul>

<p>But, what does it mean for a type to require memory, and where does that memory come from and how is it managed? Understanding the memory model in C is vital to becoming a good programmer because there are situations where you have to use complex memory management to write effective programs. Simple mistakes can lead to programs with mysterious bugs that fail in inexplicable ways.</p>

<p><a id="orgac8542c"></a></p>
      <h1 id="local-memory-allocation-on-the-stack">
        
        
          Local Memory Allocation on the Stack <a href="#local-memory-allocation-on-the-stack">#</a>
        
        
      </h1>
    

<p>When you declare a variable, you are actually stating to C that you need to create space for the data of that variable to exist. Consider a very simple example.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<p>The declaration of the integer <code class="language-plaintext highlighter-rouge">a</code> will allocate memory for the storage for an integer (4-bytes). We refer to the data stored in memory via the variable <code class="language-plaintext highlighter-rouge">a</code>.</p>

<p><strong>Memory allocation</strong> refers to the process by which the program makes “space” for the storage of data. When you declare a variable of a type, enough memory is allocation locally to store data of that type. The allocation is local, occurring within the scope of the function, and when that function returns the memory is <strong>deallocated</strong>. This should be intuitive based on your experience with programming so far, you can’t reference a variable outside the scope of your function.</p>

<p>However with pointers in C, it’s easy to make mistakes where your pointer references a memory address out of scope of the current function or even completely unallocated memory. As an example of a common mistake, consider the simple program below which has a function <code class="language-plaintext highlighter-rouge">plus()</code> which adds two numbers and returns a memory address for the result value.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="nf">plus</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>    <span class="c1">//return a reference to</span>
                <span class="c1">//locally declared c</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">plus</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="c1">//dereference return value</span>
                      <span class="c1">//to print an integer </span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function plus is declared to take two integers as arguments and return a pointer to an integer. Within the body of the function, the two integers are summed together, and the result in stored in <code class="language-plaintext highlighter-rouge">c</code>, a variable declared locally within the context of the function. The function then returns the memory address of <code class="language-plaintext highlighter-rouge">c</code>, which is assigned to the pointer value <code class="language-plaintext highlighter-rouge">p</code> in main.</p>

<p>What’s the problem? The memory of <code class="language-plaintext highlighter-rouge">c</code> is deallocated once the function returns, and now <code class="language-plaintext highlighter-rouge">p</code> is referencing a memory address which is unallocated. The print statement, which deferences <code class="language-plaintext highlighter-rouge">p</code>, following the pointer to the memory address, may fail. The above code is <strong>bad</strong>, and you can also follow the reasoning with a stack diagram.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            plus(1,2)         return &amp;c            printf("%d\n",*p)
             
(main)         |  (main)         |  (main)            |  (main)
.---.----.     |  .---.----.     |  .---.----.        |  .---.----.
| p |  .-+-X   |  | p |  .-+-X   |  | p |  .-+---.    |  | p |  .-+---.
'---'----'     |  '---'----'     |  '---'----'   |    |  '---'----'   |
               | -------------   | ------------  |    |               |
               |  (plus)         |  (plus)       |    |               |
               |  .---.---.      |  .---.---.    |    |               |
               |  | a | 1 |      |  | a | 1 |    |    |               |
               |  |---|---|      |  |---|---|    |    |               |
               |  | b | 2 |      |  | b | 2 |    |    |               |
               |  |---|---|      |  |---|---|    |    |               |
               |  | c | 3 |      |  | c | 3 | &lt;--'    |            X--'
               |  '---'---'      |  '-------'
                
                c exists locally    returning a reference       When p is dereferenced
                in plus()           to c assined to p           it points to unallocated memory
</code></pre></div></div>

<p>First, in <code class="language-plaintext highlighter-rouge">main()</code>, p waits for the result of the call to <code class="language-plaintext highlighter-rouge">plus()</code>, which set’s <code class="language-plaintext highlighter-rouge">c</code>. Once <code class="language-plaintext highlighter-rouge">plus()</code> returns, the value of <code class="language-plaintext highlighter-rouge">p</code> references a variable declared in <code class="language-plaintext highlighter-rouge">plus()</code>, but all locally declared variables in <code class="language-plaintext highlighter-rouge">plus()</code> are deallocated once <code class="language-plaintext highlighter-rouge">plus()</code> returns. That means, by the time the <code class="language-plaintext highlighter-rouge">printf()</code> is called and <code class="language-plaintext highlighter-rouge">p</code> is dereferenced, the memory address references unallocated memory, and we cannot guarantee that the data at that memory address will be what we expect.</p>

<p><a id="org0b3f7e7"></a></p>
      <h2 id="the-stack">
        
        
          The Stack <a href="#the-stack">#</a>
        
        
      </h2>
    

<p>Another term for local memory allocation is <strong>stack allocation</strong> because the way programs track execution across functions is based on a stack. A <strong>stack</strong> is a standard ordered data structure, like a list, that has the property that the <em>last item</em> inserted on the stack is the <em>first item</em> that is removed. This is often referred to as LIFO data structure, last-in-first-out. A stack has two primary functions:</p>

<ul>
  <li><strong>push</strong> : push an item on to the top of the stack</li>
  <li><strong>pop</strong> : pop an item off the top of the stack</li>
</ul>

<p>The stack’s <strong>top</strong> always references the last item pushed onto the stack, and the items below the top are ordered base on when they were pushed on. The most recently pushed items come first. This means when you pop items off the top stack, the next item becomes the next top, which maintains the LIFO principle.</p>

<p>The stack model (last-in-first-out) matches closely the model of function calls and returns during program execution. The act of calling a function is the same as <em>pushing</em> the called function execution onto the top of the stack, and, once that function completes, the results are returned <em>popping</em> the function off the stack.</p>

<p>Each function is contained within a structure on the stack called a <strong>stack frame</strong>. A stack frame contains all the allocated memory from variable declarations as well as a pointer to the execution point of the calling function, the so called <strong>return pointer</strong>. A very common exploit in computer security is a buffer overflow attack where an attacker overwrite the return pointer such that when the function returns, code chosen by the attacker is executed.</p>

<p>To understand how function calls are modeled in the stack, we have nested function calls under <code class="language-plaintext highlighter-rouge">addonetwo()</code>, and which ever function is currently executing has the stack frame at the top of the stack and the calling function, where to the current function returns, is the stack frame next from top. When the current function returns, its stack frame is popped off the stack, and the calling function, now the top of the stack, continues executing from the point of function call.</p>

<div class="side-by-side">
  <div class="side-by-side-a">

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">gettwo</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span> 

<span class="kt">int</span> <span class="nf">getone</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">addonetwo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">one</span> <span class="o">=</span> <span class="n">getone</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">two</span> <span class="o">=</span> <span class="n">gettwo</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">one</span> <span class="o">+</span> <span class="n">two</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">addonetwo</span><span class="p">();</span>

<span class="p">}</span>
</code></pre></div>    </div>

  </div>
  <div class="side-by-side-b">

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            program executed     .------ top of stack
                                 v
                main()
push main         |      |     main()     |
                  |      '----------------' 

              addonetwo()
                  |
push addonetwo    |      |   addonetwo()  |
                  |      |     main()     |
                  |      '----------------'

               getone()
                  |
                  |      |     getone()   |
push getone       |      |   addonetwo()  |
                  |      |     main()     |
                  |      '----------------'

               return 1
pop               |      |   addonetwo()  |
                  |      |     main()     |
                  |      '----------------'

               gettwo()
                  |
                  |      |     gettwo()   |
push gettwo       |      |   addonetwo()  |
                  |      |     main()     |
                  |      '----------------'

               return 2
pop               |      |   addonetwo()  |
                  |      |     main()     |
                  |      '----------------'

           return  1 + 2 
pop               |      |     main()     |
                  |      '----------------'

             program exits
</code></pre></div>    </div>

  </div>
</div>

<p>The act of pushing and popping functions onto the stack also affects the memory allocation. By <em>pushing</em> a function onto the stack, the computer is actually allocating memory for the function’s local variables, and once that function returns, the function and its allocated memory is <em>popped</em> off the stack, deallocating it. This is why local declared variables are also called <strong>stacked variables</strong>.</p>

<p>Following the example from before we can now better understand why it fails by adding in the pushes and pops of the stack.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            *PUSH*            *POP*

            plus(1,2)         return &amp;c            printf("%d\n",*p)
             
(main)         |  (main)         |  (main)            |  (main)
.---.----.     |  .---.----.     |  .---.----.        |  .---.----.
| p |  .-+-X   |  | p |  .-+-X   |  | p |  .-+---.    |  | p |  .-+---.
'---'----'     |  '---'----'     |  '---'----'   |    |  '---'----'   |
               | -------------   | ------------  |    |               |
               |  (plus)         |  (plus)       |    |               |
               |  .---.---.      |  .---.---.    |    |               |
               |  | a | 1 |      |  | a | 1 |    |    |               |
               |  |---|---|      |  |---|---|    |    |               |
               |  | b | 2 |      |  | b | 2 |    |    |               |
               |  |---|---|      |  |---|---|    |    |               |
               |  | c | 3 |      |  | c | 3 | &lt;--'    |            X--'
               |  '---'---'      |  '-------'
                
             Pusing plus()           The return of plus()      When p is dereferenced          
             onto the stack          pops it off the stack     in the print, p now 
             allocates memory        unallocated all stack     references unallocated
             for c                   variables including c     memory
</code></pre></div></div>

<p><a id="org57cfe3a"></a></p>
      <h1 id="global-memory-allocation-on-the-heap">
        
        
          Global Memory Allocation on the Heap <a href="#global-memory-allocation-on-the-heap">#</a>
        
        
      </h1>
    

<p>Just because the sample program with <code class="language-plaintext highlighter-rouge">plus()</code> from the previous section doesn’t work properly when returning a memory reference, it does not mean you cannot write functions that return a memory reference. What is needed is a different allocation procedure for global memory which is not deallocated automatically when functions return and thus remains in scope for the entirety of the program execution.</p>

<p>In fact, you have already seen how to do this in Java when you using the <code class="language-plaintext highlighter-rouge">new</code> construct.</p>

<p>If you think about it, the memory cannot have been allocated on the stack because it is memory being returned from a function, the <code class="language-plaintext highlighter-rouge">new</code> function. As we’ve seen previously, if a function returns a local reference of a variable declared on the stack, that memory is automatically deallocated when the function returns. Instead, this memory must have been allocated somewhere else, and it is. The <code class="language-plaintext highlighter-rouge">new</code> function performs a dynamic memory allocation in global memory that is not associated with scope of functions or the stack. It is instead allocating on the <strong>heap</strong>.</p>

<p><a id="org307726c"></a></p>
      <h2 id="the-heap-malloc-and-free">
        
        
          The heap, <code class="language-plaintext highlighter-rouge">malloc()</code> and <code class="language-plaintext highlighter-rouge">free()</code> <a href="#the-heap-malloc-and-free">#</a>
        
        
      </h2>
    

<p>The global memory region for a program is called the <strong>heap</strong>, which is a fragmented data structure where new allocations try and fit within unallocated regions. Whenever a program needs to allocate memory globally or in a dynamic way, that memory is allocated on the heap, which is shared across the entire program irrespective of function calls.</p>

<p>In C the <code class="language-plaintext highlighter-rouge">new</code> function is called <code class="language-plaintext highlighter-rouge">malloc()</code>, or memory allocator. The <code class="language-plaintext highlighter-rouge">malloc()</code> function takes the number of bytes to be allocated as its argument, and it returns a pointer to a memory region on the heap of the requested byte-size. Here is a code snippet to allocate memory to store an integer on the heap:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//                           .--- Allocate sizeof(int) number of bytes </span>
<span class="c1">//                           v</span>
 <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="c1">//            ^</span>
<span class="c1">//            '-- Cast to a integer pointer</span>
</code></pre></div></div>

<p>First, to allocate an integer on the heap, we have to know how <strong>big</strong> an integer is, that is, what size is it, which we learn via <code class="language-plaintext highlighter-rouge">sizeof()</code> function. Since an <code class="language-plaintext highlighter-rouge">int</code> is 4 byes in size, <code class="language-plaintext highlighter-rouge">malloc()</code> will allocate 4 bytes of memory on the heap in which an integer can be stored. <code class="language-plaintext highlighter-rouge">malloc()</code> then returns the memory address of the newly allocated memory, which is assigned to <code class="language-plaintext highlighter-rouge">p</code>. Since <code class="language-plaintext highlighter-rouge">malloc()</code> is a general purpose allocation tool, just allocating bytes which can be used to store data generally, we have to cast the resulting pointer value to the right type, <code class="language-plaintext highlighter-rouge">int *</code>. If we don’t, the program won’t fail, but you will get a compiler warning.</p>

<p>We can now use <code class="language-plaintext highlighter-rouge">p</code> like a standard pointer as before; however, once we’re done with <code class="language-plaintext highlighter-rouge">p</code> we have to explicitly deallocate it. <strong>Unlike stack based memory allocations which are implicitly deallocated when functions return, there is no way for C to know when you are done using memory allocated on the heap.</strong> C does not track references, like Java, so it can’t perform garbage collection; instead, you, the programmer, must indicate when you’re done with the memory by <em>freeing</em>. The deallocation function is <code class="language-plaintext highlighter-rouge">free()</code>, which takes a pointer value as input and “frees” the referenced memory on the heap.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="c1">//do something with p</span>

<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">//&lt;-- deallocate p</span>
</code></pre></div></div>

<p>With all of that, we can now complete the <code class="language-plaintext highlighter-rouge">plus()</code> program to properly return a memory reference to the result.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="nf">plus</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> 
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">//allocate enough space for </span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>                   <span class="c1">//for an integer</span>
  <span class="k">return</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">//return pointer</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">plus</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//p now references memory on the heap</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span> 
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">//free allocated memory</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a id="org0601a96"></a></p>
      <h2 id="program-layout-stack-vs-heap">
        
        
          Program Layout: Stack vs. Heap <a href="#program-layout-stack-vs-heap">#</a>
        
        
      </h2>
    

<p>Now that you understand the two different memory allocation procedures, let’s zoom out and take a larger look at how memory in programs is managed more generally. Where is the stack? Where is the heap? How do they grow or shrink?</p>

<p>To answer these questions, you first need to think of a program as a memory profile. All information about a program, including the actual binary code and variables all are within the memory layout of a program. When executing, the Operating System will manage that memory layout, and a snapshot of that memory and the current execution point basically defines a program. This allows the operating system to swap in and out programs as needed.</p>

<p>On 64-bit machines, the total available memory addresses are from 0 to 2<sup>64</sup>-1. For a program, the top and bottom of the address space are what is important. We can look at the program’s memory layout in diagram form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     2^64-1---&gt;  .----------------------.
High Addresses   |      Enviroment      |
                 |----------------------|
                 |                      |   Functions and variable are declared
                 |         STACK        |   on the stack.
base pointer -&gt;  | - - - - - - - - - - -|
                 |           |          |
                 |           v          |
                 :                      :
                 .                      .   The stack grows down into unused space
                 .         Empty        .   while the heap grows up. 
                 .                      .
                 .                      .   (other memory maps do occur here, such 
                 .                      .    as dynamic libraries, and different memory
                 :                      :    alloocat)
                 |           ^          |
                 |           |          |
 break point -&gt;  | - - - - - - - - - - -|   Dynamic memory is declared on the heap
                 |          HEAP        |
                 |                      |
                 |----------------------|
                 |          BSS         |   The compiled binary code is down here as
                 |----------------------|   well as static and initialzed data
                 |          Data        |
                 |----------------------|
Low Addresses    |          Text        |
      0 -----&gt;   '----------------------'  
</code></pre></div></div>

<p>At the higher addresses is the stack and at the lower address is the heap. The two memory allocation regions grow into the middle of the address space, which is unused and unallocated. In this way, the two allocations will not interfere with each other. The stack <strong>base pointer</strong> is the current top of the stack, and as functions are called and returned, it will shift appropriately. The <strong>break point</strong> refers to the top of the programs data segment, which contains the heap. As the heap fills up, requirement more space, the break is set to higher addresses.</p>

<p>You should note that this memory layout is <strong>virtual</strong>. From the program’s perspective it has access to the entire address range, but in reality, this might not be the case because the program is sharing <strong>physical memory</strong> with other programs, including the operating system. How that process works is a discussion for another class.</p>
      <h1 id="memory-leaks-and-memory-violations">
        
        
          Memory Leaks and Memory Violations <a href="#memory-leaks-and-memory-violations">#</a>
        
        
      </h1>
    

<p>In C, the programmer is responsible for memory management, which includes both the allocation and deallocation of memory. As a result, there are many mistakes that can be made, which is natural considering that all programmers make mistakes. Perhaps the most common mistake is a memory leak, where heap allocated memory is not freed. Consider the following program.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>At the <code class="language-plaintext highlighter-rouge">malloc</code>, on line 5, the returned pointer to newly allocated memory is overwriting the previous value of <code class="language-plaintext highlighter-rouge">p</code>. There is no <code class="language-plaintext highlighter-rouge">free()</code> occuring, and once the previous pointer value is overwritten, there is no way to free that memory. It is considered <em>lost</em>, and the above program has a memory leak. Memory leaks are very bad, and over time, can cause your program to fail.</p>

<p>Another common mistake is dereferencing a <strong>dangling pointer</strong>. A dangling pointer is when a pointer value once referenced allocated memory, but that memory has seen been deallocated. We see an example of this already in the <code class="language-plaintext highlighter-rouge">plus()</code> program, but it can also occur for heap allocations.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="c1">//... code</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="c1">//... code  </span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once <code class="language-plaintext highlighter-rouge">p</code> has been freed, the memory referenced by the <code class="language-plaintext highlighter-rouge">p</code>’s value can be reclaimed by other allocations. At the point where <code class="language-plaintext highlighter-rouge">p</code> is dereferenced for the assignment, it might be the case that you are actually overwriting memory for some other value, and corrupting your program. Once memory is freed, it should never be dereferenced. These kinds of memory violations can lead to the dreaded <code class="language-plaintext highlighter-rouge">SEGFAULT</code>.</p>

<p>Another, common mistake with memory allocation is a <strong>double free</strong>. The heap allocation functions maintain special data structures so that it is easy to find unallocated memory and reallocate for future <code class="language-plaintext highlighter-rouge">malloc()</code> calls. If you call <code class="language-plaintext highlighter-rouge">free()</code> twice on a pointer, you will corrupt that process, result in a <code class="language-plaintext highlighter-rouge">core dump</code> or some other very scary error.</p>
      <h2 id="using-valgrind-to-detect-memory-leaks-and-violations">
        
        
          Using Valgrind to Detect Memory Leaks and Violations <a href="#using-valgrind-to-detect-memory-leaks-and-violations">#</a>
        
        
      </h2>
    

<p>Memory leaks and violations are pernicious and extremely hard to debug. At times it may appear everything is running correctly, only for later in your code for you to realize that everything is bunk. So it’s really important for you to identify and remove memory leaks and violations from your code.</p>

<p>An important tool in the fight to eradicate memory leaks and violations is <code class="language-plaintext highlighter-rouge">valgrind</code>. The way <code class="language-plaintext highlighter-rouge">valgrind</code> works is that it traces your program, tracking each call to <code class="language-plaintext highlighter-rouge">malloc</code> and <code class="language-plaintext highlighter-rouge">free</code>, ensuring that there is an associated <code class="language-plaintext highlighter-rouge">free</code> for every allocated memory. It also tracks all pointer dereferences, checking to make sure that you follow pointers to usable/valid memory (thus ensuring that there isn’t a memory violation).</p>

<p>Let’s look at a few examples of using <code class="language-plaintext highlighter-rouge">valgrind</code> to debug some obvious memory leaks.</p>
      <h3 id="debugging-a-memleak-with-valgrind">
        
        
          Debugging a memleak with valgrind <a href="#debugging-a-memleak-with-valgrind">#</a>
        
        
      </h3>
    

<p>Consider the incorrect code below:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//memleak.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"*p = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">//&lt;-- memory leak</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"*p = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This example is a bit obvious, but it’s almost always not this clear why you have a memory leak. So we can turn our attention to <code class="language-plaintext highlighter-rouge">valgrind</code>, but before, we should compile our program with debugging symbols using <code class="language-plaintext highlighter-rouge">-g</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -g memleak.c -o memleak
</code></pre></div></div>
<p>This gives <code class="language-plaintext highlighter-rouge">valgrind</code> access to the exact line of code and variable names to give you more information about what is wrong. After compiling the program, you run it like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind ./memleak
</code></pre></div></div>

<p>Getting the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>==3367== Memcheck, a memory error detector
==3367== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==3367== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==3367== Command: ./memleak
==3367== 
*p=10
*p=20
==3367== 
==3367== HEAP SUMMARY:
==3367==     in use at exit: 4 bytes in 1 blocks
==3367==   total heap usage: 3 allocs, 2 frees, 1,032 bytes allocated
==3367== 
==3367== LEAK SUMMARY:
==3367==    definitely lost: 4 bytes in 1 blocks
==3367==    indirectly lost: 0 bytes in 0 blocks
==3367==      possibly lost: 0 bytes in 0 blocks
==3367==    still reachable: 0 bytes in 0 blocks
==3367==         suppressed: 0 bytes in 0 blocks
==3367== Rerun with --leak-check=full to see details of leaked memory
==3367== 
==3367== For lists of detected and suppressed errors, rerun with: -s
==3367== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre></div></div>

<p>Notice that it clearly says that 4 bytes were <strong>definitely</strong> lost. And it even helpfully tells you to rerun your program with <code class="language-plaintext highlighter-rouge">--leak-check=full</code> to see details of leaked memory. So let’s do that, and we get the additional information:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>==4310== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==4310==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==4310==    by 0x10919E: main (memleak.c:6)
</code></pre></div></div>

<p>This says: the memory that was lost was allocated using <code class="language-plaintext highlighter-rouge">malloc</code> on line 6 of our program. Wow! Very specific. Looking at our program we see exactly where that occurred, and this allows us to fix it. Unfortunately, though, it can’t tell us where to put the <code class="language-plaintext highlighter-rouge">free</code>, but it does tell us that we need to do so somewhere.</p>
      <h3 id="understanding-a-memory-violation-using-valgrind">
        
        
          Understanding a memory violation using valgrind <a href="#understanding-a-memory-violation-using-valgrind">#</a>
        
        
      </h3>
    

<p>To see an example of a memory violation, let’s look at another incorrect program.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//memviolation.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"*p = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>    
    
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">//&lt;-- memory violation (accessing invalid memory)</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"*p = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="c1">//&lt;-- memory violation (accessing invalid memory)</span>
 
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//&lt;-- memory violation (double free)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that we derference and assign to <code class="language-plaintext highlighter-rouge">*p</code> after freeing <code class="language-plaintext highlighter-rouge">p</code>, then later we again dereference when printing, and then again, we double free p (it’s already been freed!). This is a slew of memory violation, and<code class="language-plaintext highlighter-rouge">valgrind</code> will identify all of these. Let’s look at the output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>==5489== Memcheck, a memory error detector
==5489== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==5489== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==5489== Command: ./memviolation
==5489== 
*p=10
==5489== Invalid write of size 4
==5489==    at 0x1091D6: main (memviolation.c:13)
==5489==  Address 0x4a44040 is 0 bytes inside a block of size 4 free'd
==5489==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==5489==    by 0x1091D1: main (memviolation.c:11)
==5489==  Block was alloc'd at
==5489==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==5489==    by 0x10919E: main (memviolation.c:6)
==5489== 
==5489== Invalid read of size 4
==5489==    at 0x1091E0: main (memviolation.c:15)
==5489==  Address 0x4a44040 is 0 bytes inside a block of size 4 free'd
==5489==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==5489==    by 0x1091D1: main (memviolation.c:11)
==5489==  Block was alloc'd at
==5489==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==5489==    by 0x10919E: main (memviolation.c:6)
==5489== 
*p=20
==5489== Invalid free() / delete / delete[] / realloc()
==5489==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==5489==    by 0x109200: main (memviolation.c:17)
==5489==  Address 0x4a44040 is 0 bytes inside a block of size 4 free'd
==5489==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==5489==    by 0x1091D1: main (memviolation.c:11)
==5489==  Block was alloc'd at
==5489==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==5489==    by 0x10919E: main (memviolation.c:6)
==5489== 
==5489== 
==5489== HEAP SUMMARY:
==5489==     in use at exit: 0 bytes in 0 blocks
==5489==   total heap usage: 2 allocs, 3 frees, 1,028 bytes allocated
==5489== 
==5489== All heap blocks were freed -- no leaks are possible
==5489== 
==5489== For lists of detected and suppressed errors, rerun with: -s
==5489== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
</code></pre></div></div>

<p>First, notice that at the end it lists 3 errors, which match up to the three violations in the code. Then above, the first of these errors is an invalid write. This occurs when we <code class="language-plaintext highlighter-rouge">*p=20</code> because <code class="language-plaintext highlighter-rouge">p</code> is already free. The second error is an invalid read when we use <code class="language-plaintext highlighter-rouge">*p</code> in our <code class="language-plaintext highlighter-rouge">printf()</code>, and finally, the third error, is a invalid <code class="language-plaintext highlighter-rouge">free()</code> when we free <code class="language-plaintext highlighter-rouge">p</code> for the second time. Again, <code class="language-plaintext highlighter-rouge">valgrind</code> notes the location in code these events occurred at, which gives us a start on fixing our code, but we still have to reason about <em>why</em> there is an error. That’s the hard part.</p>
      <h1 id="dynamic-array-allocation">
        
        
          Dynamic Array Allocation <a href="#dynamic-array-allocation">#</a>
        
        
      </h1>
    

<p>From the last class, we discuss the standard memory allocation situation where we need to allocate memory on the heap.</p>

<div class="side-by-side">
  <div class="side-by-side-a">

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div>    </div>

  </div>
  <div class="side-by-side-b">

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> STACK          HEAP
.---.----.     .----.
| p |  .-+----&gt;| 10 |
'---'----'     '----'
</code></pre></div>    </div>

  </div>
</div>

<p>On the left, we use <code class="language-plaintext highlighter-rouge">malloc()</code> to allocate enough memory to store an <code class="language-plaintext highlighter-rouge">int</code>, and we assign the address of that memory to the integer pointer, <code class="language-plaintext highlighter-rouge">p</code>. On the right, is the stack diagram of this allocation. The pointer <code class="language-plaintext highlighter-rouge">p</code> exists on the stack, but it now references the memory on the heap.</p>

<p>We now know, in excruciating detail, that arrays and pointers are the same. This idea extends to the dynamic allocation of arrays. If we have an integer pointer <code class="language-plaintext highlighter-rouge">p</code> it can point to a single integer, or it can point to the start of a sequence of integers. A sequence of contiguous integers <em>is</em> an array. All we need is to allocate enough space to store all those integers, and <code class="language-plaintext highlighter-rouge">malloc()</code> can do that too.</p>

<p>Consider what’s needed to allocate an array of a given size. For example, how many bytes would be needed to allocate an integer array of size 5? There are 4-bytes for each integer, and the array holds 5 integers: 20 bytes. To allocate the array, we just ask <code class="language-plaintext highlighter-rouge">malloc()</code> to allocate 20 bytes, and cast the result to an <code class="language-plaintext highlighter-rouge">int *</code>, like below.</p>

<div class="side-by-side">
  <div class="side-by-side-a">

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="c1">//...</span>
<span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</code></pre></div>    </div>

  </div>
  <div class="side-by-side-b">

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> STACK          HEAP
.---.----.     .----.
| p |  .-+----&gt;| 10 | p[0]
'---'----'     |----|
               | 20 | p[1]
               |----|
               :    :  
               .    .
               :    :
               |----|
               | 50 | p[4]
               '----'
</code></pre></div>    </div>

  </div>
</div>

<p>The result of the <code class="language-plaintext highlighter-rouge">malloc()</code> is 20 bytes of contiguous memory which is referenced by an integer pointer, which is the <strong>same</strong> as an array! We can even use the array indexing method, <code class="language-plaintext highlighter-rouge">[]</code>, to access and assign to the array.</p>

<p><a id="org78608e2"></a></p>
      <h2 id="array-allocation-with-calloc">
        
        
          Array allocation with <code class="language-plaintext highlighter-rouge">calloc()</code> <a href="#array-allocation-with-calloc">#</a>
        
        
      </h2>
    

<p>Because allocating items as an array is so common, we have a special function for it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div></div>

<p>While allocating arrays with <code class="language-plaintext highlighter-rouge">malloc()</code> is simple and effective, it can be problematic. First off, <code class="language-plaintext highlighter-rouge">malloc()</code> makes no guarantee that memory allocated will be clean — it can be anything. For example, consider this simple program:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//allocate a 20 byte array</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>What is the output of this program? We don’t know. It’s undefined. The allocated memory from <code class="language-plaintext highlighter-rouge">malloc()</code> can have any value, usually whatever value the memory used to have if it was previously allocated. If you don’t believe me, try running and executing the program a few times, and you’ll see that you can get widely different results.</p>

<p>The second problem with using <code class="language-plaintext highlighter-rouge">malloc()</code> is that it is a multi-purpose allocation tool. It is generally designed to allocate memory of a given size that can be used for both arrays and other data types. This means that to allocate an array of the right size, you have to perform an arithmetic computation, like <code class="language-plaintext highlighter-rouge">20 * sizeof(int)</code>, which is non-intuitive and reduces the readability of code.</p>

<p>To address these issues, there is a special purpose allocator that is a lot more effective for array allocation. It’s <code class="language-plaintext highlighter-rouge">calloc()</code> or the <em>counting allocator</em>. It’s usage is as follows.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  The number of items </span>
<span class="c1">//  to be allocated      --.</span>
<span class="c1">//                         |</span>
<span class="c1">//                         v</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="c1">//                                  ^</span>
<span class="c1">//                                  |      </span>
<span class="c1">//                            The size of each item</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">calloc()</code> takes two arguments, the number of items needed and the size of each item. For an array, that is the length of the array, and the size is the <code class="language-plaintext highlighter-rouge">sizeof()</code> the array type, which is <code class="language-plaintext highlighter-rouge">int</code> in this case. Not only does <code class="language-plaintext highlighter-rouge">calloc()</code> make the array allocation more straight forward, it will also zero-out or clean the memory that is allocated. For example, this program will always print 0’s.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//allocate a 20 byte array</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 0 b/c calloc zeros out allocated memory</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a id="orgbcc8dd1"></a></p>
      <h2 id="double-pointer-arrays-for-advanced-data-types">
        
        
          Double Pointer Arrays for Advanced Data Types <a href="#double-pointer-arrays-for-advanced-data-types">#</a>
        
        
      </h2>
    

<p>So far in this lesson we’ve discussed allocating basic types, but we can also dynamically allocate memory for other types, such as strings and structures. For example, consider the <code class="language-plaintext highlighter-rouge">pair_t</code> structure below:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">left</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pair_t</span><span class="p">;</span>
</code></pre></div></div>

<p>Suppose we want an array of such structures, then we can use dynamic allocation using <code class="language-plaintext highlighter-rouge">calloc()</code> to allocate array of <code class="language-plaintext highlighter-rouge">pair_t</code>’s just like we did to generate an array of <code class="language-plaintext highlighter-rouge">int</code>’s.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pair_t</span> <span class="o">*</span> <span class="n">pairs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pair_t</span><span class="p">));</span>

<span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">left</span>  <span class="o">=</span>  <span class="mi">2</span><span class="p">;</span>  <span class="c1">//do assignment</span>
<span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">right</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<p>As you can see, once the array is generated, we can access each individual <code class="language-plaintext highlighter-rouge">pair_t</code> using array indexing, and the array was allocated with enough memory for 10 <code class="language-plaintext highlighter-rouge">pair_t</code> strucutes we use the <code class="language-plaintext highlighter-rouge">.</code> operator to access each item.</p>

<p>This allocation is fine for many circumstances, but it can pose some subtle problems in certain situations. Suppose we wanted to keep track of which pairs have been set and which have not? Could we just look at the array of pairs and know this? We can’t because <code class="language-plaintext highlighter-rouge">calloc()</code> will zero out all the pairs and we can’t tell difference between a pair just stores to zeros and one that was not set. Another problem could occur if we want to be memory efficient. What if we only want to allocate the full <code class="language-plaintext highlighter-rouge">pair_t</code> struct as needed?</p>

<p>Adding an extra layer of redirection makes such tasks much easier. Essentially, we wish to construct an array of pointers to the desired type, or a pointer to a pointer, a <strong>double pointer</strong>. Instead of having an array of <code class="language-plaintext highlighter-rouge">pair_t</code>’s, we have an array of pointers to <code class="language-plaintext highlighter-rouge">pair_t</code>’s. Then we can know if the <code class="language-plaintext highlighter-rouge">pair_t</code> is set because either the pointer will be <code class="language-plaintext highlighter-rouge">NULL</code> or it will reference a <code class="language-plaintext highlighter-rouge">pair_t</code>, and we can allocate new <code class="language-plaintext highlighter-rouge">pair_t</code>’s as needed. The allocation is as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//     .-- Double Pointer -.          array of pair_t pointers</span>
<span class="c1">//     |                   |                      |</span>
<span class="c1">//     v                   v                      v</span>
<span class="n">pair_t</span> <span class="o">**</span> <span class="n">pairs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair_t</span> <span class="o">**</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pair_t</span> <span class="o">*</span><span class="p">));</span>

<span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pair_t</span><span class="p">));</span> <span class="c1">//allocate memory for a new pair_t</span>

<span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span>  <span class="mi">2</span><span class="p">;</span> <span class="c1">//do assignment</span>
<span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<p>While at first this might seem like a funky and unnecessary way of allocating structure types, but it is quite common in practice. It is often the case that you will need to store and reference a number of structure types, the amount of them is unknown ahead of time. Managing all this data requires careful programming and memory management. Keeping track of what has been allocated, what has been freed, and what resources are newly available are the key to designing good programs.</p>

<p><a id="org91b25d1"></a></p>
      <h2 id="deallocating-double-pointers">
        
        
          Deallocating Double Pointers <a href="#deallocating-double-pointers">#</a>
        
        
      </h2>
    

<p>A common mistake when dealing with double pointers is poor deallocation. Let’s extend the above example by modularizing the process of creating the array of pair pointers and the addition of a new pair into functions to simplify the code. This might look like below.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">pair_t</span> <span class="o">**</span> <span class="nf">new_pairs</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pair_t</span> <span class="o">**</span> <span class="n">pairs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair_t</span> <span class="o">**</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pair_t</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">pairs</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pair_t</span> <span class="o">*</span> <span class="nf">add_pair</span><span class="p">(</span><span class="n">pair_t</span> <span class="o">**</span> <span class="n">pairs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pair_t</span><span class="p">));</span> <span class="c1">//allocate</span>

      <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span><span class="c1">//do asignment</span>
      <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>

      <span class="k">return</span> <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//return the new pair</span>
    <span class="p">}</span>
  <span class="p">}</span>  
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//list full, return NULL for error</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">pair_t</span> <span class="o">**</span> <span class="n">pairs</span> <span class="o">=</span> <span class="n">new_pairs</span><span class="p">();</span> <span class="c1">//create a new pair array</span>

  <span class="n">add_pair</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">//assign a new pair</span>
  <span class="n">add_pair</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">//assign a new pair</span>
  <span class="c1">//...</span>
  <span class="c1">// deallocate?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, the addition of a new pair is as simple as calling <code class="language-plaintext highlighter-rouge">add_pair()</code> which will find the first <code class="language-plaintext highlighter-rouge">NULL</code> pointer in the <code class="language-plaintext highlighter-rouge">pairs</code> array to do the insert. If the array is full, it returns <code class="language-plaintext highlighter-rouge">NULL</code> on error.</p>

<p>This is great! We’ve just generalized our double pointer array into a mini data structure that is memory efficient and easy to use. There’s one problem though, how do we properly deallocate the double pointer to make sure we don’t have a memory leak? The following will not work:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">delete_pairs</span><span class="p">(</span><span class="n">pair_t</span> <span class="o">**</span> <span class="n">pairs</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">free</span><span class="p">(</span><span class="n">pairs</span><span class="p">);</span> <span class="c1">// memory leak!!!  </span>
<span class="p">}</span>
</code></pre></div></div>

<p>This will cause a memory leak because the index of pairs are pointers which may reference other allocated memory. You can’t just free up the larger array without first deallocating any memory referenced from within the array. If you do, then the address of that memory will be lost, thus leaking the memory.</p>

<p>Instead, you have to be more careful and generate a code block to deallocate it properly.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">delete_pairs</span><span class="p">(</span><span class="n">pair_t</span> <span class="o">**</span> <span class="n">pairs</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//don't want to free(NULL), cause coredump</span>
       <span class="n">free</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">//free allocated memory within array</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">free</span><span class="p">(</span><span class="n">pairs</span><span class="p">);</span> <span class="c1">//free array</span>
<span class="p">}</span>
</code></pre></div></div>
      <h1 id="programming-a-dynamic-data-structure-in-c">
        
        
          Programming a Dynamic Data Structure in C <a href="#programming-a-dynamic-data-structure-in-c">#</a>
        
        
      </h1>
    

<p>We now have everything we need to do some more advanced programming in C, notably, to program a data structure. Let’s look at what it takes to implement stack in C using a linking data structure. Recall that a stack is a first-in-first-out (FIFO) data structure with the following interface.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">push(e)</code> : push an element onto the stack</li>
  <li><code class="language-plaintext highlighter-rouge">pop(e)</code> : pop an emelemnt off of the stack</li>
  <li><code class="language-plaintext highlighter-rouge">isEmpty()</code> : return true if the stack is empty</li>
  <li><code class="language-plaintext highlighter-rouge">size()</code> : return the number of elements on the stack</li>
</ul>

<p>For our example, we’ll store a stack of strings, just to make it a bit more interesting. We’ll call this stack a <code class="language-plaintext highlighter-rouge">sstack</code> for a string stack.</p>
      <h2 id="header-file">
        
        
          Header File <a href="#header-file">#</a>
        
        
      </h2>
    

<p>To start with, we want to make our stack usable in multiple programs, so we should create our own header file for the stack. We can call this <code class="language-plaintext highlighter-rouge">sstack.h</code> for “string stack”, and in it, we wan declare our structures and functions that will comprise it.</p>
      <h4 id="structures-of-a-sstack">
        
        
          Structures of a <code class="language-plaintext highlighter-rouge">sstack</code> <a href="#structures-of-a-sstack">#</a>
        
        
      </h4>
    

<p>First, let’s note that if we are using a linked-list like data structure for our stack, we need to declare nodes and links between those nodes. So we can start there:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">;</span> <span class="c1">//string</span>
   <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span> <span class="c1">//pointer to the next node</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span> <span class="n">node_t</span><span class="p">;</span> <span class="c1">//typedef so we can use node_t</span>
</code></pre></div></div>

<p>Then we can define a <code class="language-plaintext highlighter-rouge">sstack</code> struct that keeps track of the number of nodes and the head node.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">sstack_t</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">size</span><span class="p">;</span> <span class="c1">//track it's size</span>
   <span class="n">node_t</span> <span class="o">*</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
      <h4 id="functions-over-the-sstack">
        
        
          Functions over the <code class="language-plaintext highlighter-rouge">sstack</code> <a href="#functions-over-the-sstack">#</a>
        
        
      </h4>
    

<p>Now that we know our methods, we have to declare the functions that operate over the stack. We’ll define these later when we write the source file.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">//constructor/destructor</span>
<span class="n">sstack_t</span> <span class="o">*</span> <span class="nf">new_sstack</span><span class="p">();</span> <span class="c1">//create a new sstack</span>
<span class="kt">void</span> <span class="nf">del_sstack</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">);</span> <span class="c1">//delete a stack</span>


<span class="c1">//interface</span>
<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span> <span class="nf">pop</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">size</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">);</span>
</code></pre></div></div>

<p>First, we need two functions to both create a new <code class="language-plaintext highlighter-rouge">sstack</code> and also to deallocate our <code class="language-plaintext highlighter-rouge">sstack</code>. This operates much like the <code class="language-plaintext highlighter-rouge">new</code> operator in Java, but we have to do so explicitly. Moreover, we have to create a routine for deallocating the <code class="language-plaintext highlighter-rouge">sstack</code> as this does not occur automatically in C.</p>

<p>Next, we have the interface functions. Each of these has a pointer to a <code class="language-plaintext highlighter-rouge">sstack</code> as an argument. This allows the functions to know the context of the <code class="language-plaintext highlighter-rouge">sstack</code> it is operating over. This is very similar in java to the dot-operator. That is, when you do <code class="language-plaintext highlighter-rouge">ss.push()</code> in Java, <code class="language-plaintext highlighter-rouge">ss</code> is passed as the context for which object to call <code class="language-plaintext highlighter-rouge">push</code> on. In C, however, we have to pass that context as a explicit argument.</p>
      <h3 id="source-file">
        
        
          Source File <a href="#source-file">#</a>
        
        
      </h3>
    

<p>Now that we’ve declared our types and functions, we look to define these in a source file, we can call <code class="language-plaintext highlighter-rouge">sstack.c</code>. At the top of that source file, we <code class="language-plaintext highlighter-rouge">#include</code> our header file as well as the C standard library and the string library.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"sstack.h"</span><span class="cp">
</span>
</code></pre></div></div>
      <h4 id="allocating">
        
        
          Allocating <a href="#allocating">#</a>
        
        
      </h4>
    

<p>The first thing we need to do is actually allocate the storage requirements for <code class="language-plaintext highlighter-rouge">sstack</code> in <code class="language-plaintext highlighter-rouge">new_sstack()</code>. This requires at least one <code class="language-plaintext highlighter-rouge">malloc</code> call to create a new <code class="language-plaintext highlighter-rouge">sstack_t</code> structure and also initializing that structure.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sstack_t</span> <span class="o">*</span> <span class="nf">new_sstack</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//allocate a new sstack_t struct</span>
    <span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sstack_t</span><span class="p">));</span>
    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//initiali size is 0</span>
    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//the head is null</span>
<span class="p">}</span>
</code></pre></div></div>
      <h4 id="push">
        
        
          Push <a href="#push">#</a>
        
        
      </h4>
    

<p>Given that the <code class="language-plaintext highlighter-rouge">sstack_t</code> has been initialized, we can then push new strings onto the stack. Importantly, consider that a string in C is also a pointer, and that pointer to memory can be used in other contexts – it would be outside the control of our <code class="language-plaintext highlighter-rouge">sstack</code>. This bad programming can lead to memory violations.</p>

<p>Consider the following <strong>incorrect</strong> implementation of <code class="language-plaintext highlighter-rouge">push()</code> below:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">//allocate</span>
    <span class="n">node_t</span> <span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node_t</span><span class="p">));</span>
    
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span> <span class="c1">//&lt;-- this is bad!</span>
    
    <span class="c1">//set this node to the new head</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    
    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span> <span class="c1">//increase size</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then the user of this code may do the following:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">new_sstack</span><span class="p">();</span>
    
    <span class="kt">char</span> <span class="n">word</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"Enter a word:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%99s"</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
    <span class="n">push</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Enter a second word:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%99s"</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
    <span class="n">push</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>

    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we diagram out our <code class="language-plaintext highlighter-rouge">sstack</code> we’d find that we <em>aren’t storing two words</em> but rather a pointer to the same word. That’s because we are only copying the pointer passed to push, and not the memory of the string itself.</p>

<p>For example, suppose the user entered “hello” and “world”. After “hello” we’d have the following diagram</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*stack*                    *heap*

main 
----
word: "hello" &lt;-------------------------------------.
ss: -------------------&gt;  [ size: 1 ]               |
                          [ head: --]---&gt; [str --]--'
                                          [next -]--&gt; NULL
</code></pre></div></div>

<p>After “world” was pushed … We lost the fact that we pushed “hello”.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*stack*                    *heap*

main 
----
word: "world" &lt;-------------------------------------.&lt;----------.
ss: -------------------&gt;  [ size: 1 ]               |           |
                          [ head: --]---&gt; [str --]--'           |
                                          [next -]--&gt; [str --]--'
                                                      [next -]-&gt; NULL

</code></pre></div></div>

<p>Instead, we want to <em>duplicate</em> the string and store our own copy.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">){</span>

    <span class="c1">//allocate</span>
    <span class="n">node_t</span> <span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node_t</span><span class="p">));</span>
    
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">str</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="c1">//&lt;-- create a copy of the string</span>
                          <span class="c1">//    this is a malloc!</span>
                          
    <span class="c1">//set this node to the new head</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    
    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span> <span class="c1">//increase size</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">strdup()</code> we create a malloc’ed duplication of the string, and now we have the following diagram after “world” is entered.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*stack*                    *heap*

main 
----
word: "world" 
ss: -------------------&gt;  [ size: 1 ]              .-&gt;"hello"
                          [ head: --]---&gt; [str --]-'           .-&gt;"world"
                                          [next -]--&gt; [str --]-'
                                                      [next -]-&gt; NULL

</code></pre></div></div>

<p>Where both “hello” and “world” are strings allocated on the heap.</p>
      <h4 id="pop">
        
        
          Pop <a href="#pop">#</a>
        
        
      </h4>
    

<p>For <code class="language-plaintext highlighter-rouge">pop</code> this is also a deallocation routine, as we allocated a <code class="language-plaintext highlighter-rouge">node_t</code> for each element. We need to both return the next string in the list and deallocate the node that stored that string. It will be the responsbility of the user deallocate the returned string.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">char</span> <span class="o">*</span> <span class="nf">pop</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">){</span>
    <span class="c1">//check if empty</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span> <span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">//retrieve node and str</span>
    <span class="n">node_t</span> <span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">;</span>
    
    <span class="c1">//set head to the node's next    </span>
    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    
    <span class="c1">//free the node</span>
    <span class="n">free</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="c1">//reduce the size</span>
    <span class="n">ss</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>

    <span class="c1">//return the string</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">;</span>        
<span class="p">}</span>
</code></pre></div></div>
      <h4 id="is-empty-and-size">
        
        
          Is Empty and Size <a href="#is-empty-and-size">#</a>
        
        
      </h4>
    

<p>The next two functions are pretty straight forward</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">){</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="c1">//check for NULL</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">size</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
      <h4 id="deallocating">
        
        
          Deallocating <a href="#deallocating">#</a>
        
        
      </h4>
    

<p>Finally, we need to deallocate our <code class="language-plaintext highlighter-rouge">sstack</code>. To do this we can take advantage of some of the other functions we already wrote, and remembering that the we used <code class="language-plaintext highlighter-rouge">strdup()</code> when storing the string.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">del_sstack</span><span class="p">(</span><span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">(</span><span class="n">ss</span><span class="p">)){</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span> <span class="c1">//free's the node</span>
        <span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="c1">//free's from strdup()    </span>
    <span class="p">}</span>    
    <span class="n">free</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span> <span class="c1">//free the sstack itself</span>
<span class="p">}</span>

</code></pre></div></div>
      <h3 id="using-the-sstack">
        
        
          Using the <code class="language-plaintext highlighter-rouge">sstack</code> <a href="#using-the-sstack">#</a>
        
        
      </h3>
    

<p>Finally, we can use our <code class="language-plaintext highlighter-rouge">sstack</code> in a program. Let’s consider using the stack to reverse five words.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"sstack.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="kt">char</span> <span class="n">word</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">sstack_t</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">new_sstack</span><span class="p">();</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"Enter five words</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%99s"</span><span class="p">,</span><span class="n">word</span><span class="p">);</span>
        <span class="n">push</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"Your words in reverse</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">(</span><span class="n">ss</span><span class="p">)){</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">del_sstack</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>


      </div>
    </main><footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          
            <li>
              CS 2113 Software Engineering - Fall 2022
            </li>
          
          <!-- <li><a href="https://github.com/cs2113-f22"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">cs2113-f22</span></a></li> -->
        </ul>
      </div>
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          
            <li>
               &#169; Kinga Dobolyi (2022)
            </li>
          
          
          <li><a href="mailto:kinga@gwu.edu">kinga@gwu.edu</a></li>
          
        </ul>
      </div>
      <div class="footer-col footer-col-3">
        <p>
          <a href="https://cs.seas.gwu.edu/">Computer Science</a> <br/>
          <a href="https://www.gwu.edu/">The George Washington University</a>
        </p>

      </div>
    </div>

  </div>

</footer>
</body>

</html>
